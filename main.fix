module MiscAlgos;

// TODO: move this to `Std`?
loop_rep : I64 -> a -> (I64 -> a -> LoopResult a a) -> a;
loop_rep = |count, state, body| (
    loop((0, state), |(i, state)|
        if i >= count { break $ state };
        let res = body(i, state);
        if res.is_break { break $ res.as_break };
        continue $ (i + 1, res.as_continue)
    )
);

// `fold_rep(n, state, body)` calculates `state.body(0).body(1)....body(n-1)`.
// 
// When `n <= 0`, it returns `state` as is.
fold_rep : I64 -> a -> (I64 -> a -> a) -> a;
fold_rep = |n, state, body| (
    fold_rep_rev(n, state, |i, state| body(n - i - 1, state))
);

// `fold_rep_rev(n, state, body)` calculates `state.body(n-1).body(n-2)....body(0)`.
// 
// When `n <= 0`, it returns `state` as is.
fold_rep_rev : I64 -> a -> (I64 -> a -> a) -> a;
fold_rep_rev = |n, state, body| (
    if n <= 0 { state };
    let state = body(n - 1, state);
    fold_rep_rev(n - 1, state, body)
);

// Finaite field Z/pZ.
type ZP p = struct { value : U32, prime : p };

trait p : PrimeProvider {
    create : p;
    value : p -> U32;
}

namespace ZP {
    // Create a value.
    // 
    // To specify the prime p. Create a (possibly empty) type (say, `MyP`) and implement `PrimeProvider`.
    // Then you can create a value using type annotation, e.g., `let truth_in_p = from_U32(42_U32) : ZP MyP`.
    from_U32 : [p : PrimeProvider] U32 -> ZP p;
    from_U32 = |x| (
        let p = PrimeProvider::create;
        ZP { value : x % p.value, prime : p }
    );

    power : [p : PrimeProvider] U32 -> ZP p -> ZP p;
    power = |x, e| (
        let res = ZP::from_U32(1_U32);
        loop((0_U32, res, e), |(i, res, e_to_2_to_i)| (
            if 1_U32.shift_left(i) > x { break $ res };
            let xi = x.bit_and(1_U32.shift_left(i)) != 0_U32;
            let res = if xi { res * e_to_2_to_i } else { res };
            let e_to_2_to_i_plus_1 = e_to_2_to_i * e_to_2_to_i;
            continue $ (i + 1_U32, res, e_to_2_to_i_plus_1)
        ))
    );

    inv : [p : PrimeProvider] ZP p -> ZP p;
    inv = |x| (
        let p = x.@prime.value;
        eval assert(|_|"[ZP] divide by zero!", x.@value != 0_U32);
        x.power(p - 2_U32)
    );
}

impl [p : PrimeProvider] ZP p : Eq {
    eq = |this, that| (
        let p = this.@prime.value;
        this.@value == that.@value
    );
}

impl [p : PrimeProvider] ZP p : Add {
    add = |this, that| (
        let p = this.@prime.value;
        ZP { value : (this.@value + that.@value) % p, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Neg {
    neg = |this| (
        let p = this.@prime.value;
        ZP { value : (p - this.@value) % p, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Sub {
    sub = |this, that| (
        let p = this.@prime.value;
        ZP { value : (this.@value + p - that.@value) % p, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Mul {
    mul = |this, that| (
        let p = this.@prime.value.to_U64;
        ZP { value : ((this.@value.to_U64 * that.@value.to_U64) % p).to_U32, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Div {
    div = |this, that| this * that.inv;
}

// The trait of algebraic types which provide multiplicative unit.
trait a : One {
    one : a;
}

impl [p : PrimeProvider] ZP p : One {
    one = ZP::from_U32(1_U32);
}

impl I64 : One {
    one = 1_I64;
}

// The trait of rings.
trait Ring = Add + Neg + Sub + Mul + Zero + One;

// Creates table for binomial coefficients.
// `binom_table(m).@(n).@(k)` is binom(n, k) for 0 <= k <= n < m.
binom_table : [r : Ring] I64 -> Array (Array r);
binom_table = |m| (
    fold_rep(m, [], |n, table|
        let table = table.push_back(Array::fill(n + 1, Zero::zero));
        fold_rep(n + 1, table, |r, table|
            if r == 0 || r == n { table.mod(n, set(r, One::one)) };
            let x = table.@(n - 1).@(r - 1) + table.@(n - 1).@(r);
            table.mod(n, set(r, x))
        )
    )
);