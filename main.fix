module MiscAlgos;

// TODO: move this to `Std`?
loop_rep : I64 -> a -> (I64 -> a -> LoopResult a a) -> a;
loop_rep = |count, state, body| (
    loop((0, state), |(i, state)|
        if i >= count { break $ state };
        let res = body(i, state);
        if res.is_break { break $ res.as_break };
        continue $ (i + 1, res.as_continue)
    )
);

// `fold_rep(n, state, body)` calculates `state.body(0).body(1)....body(n-1)`.
// 
// When `n <= 0`, it returns `state` as is.
fold_rep : I64 -> a -> (I64 -> a -> a) -> a;
fold_rep = |n, state, body| (
    fold_rep_rev(n, state, |i, state| body(n - i - 1, state))
);

// `fold_rep_rev(n, state, body)` calculates `state.body(n-1).body(n-2)....body(0)`.
// 
// When `n <= 0`, it returns `state` as is.
fold_rep_rev : I64 -> a -> (I64 -> a -> a) -> a;
fold_rep_rev = |n, state, body| (
    if n <= 0 { state };
    let state = body(n - 1, state);
    fold_rep_rev(n - 1, state, body)
);

// The trait of algebraic types which provide multiplicative unit.
trait a : One {
    one : a;
}

impl I64 : One {
    one = 1_I64;
}

// The trait of rings.
trait Ring = Add + Neg + Sub + Mul + Zero + One;

// Creates table for binomial coefficients.
// `binom_table(m).@(n).@(k)` is binom(n, k) for 0 <= k <= n < m.
binom_table : [r : Ring] I64 -> Array (Array r);
binom_table = |m| (
    fold_rep(m, [], |n, table|
        let table = table.push_back(Array::fill(n + 1, Zero::zero));
        fold_rep(n + 1, table, |r, table|
            if r == 0 || r == n { table.mod(n, set(r, One::one)) };
            let x = table.@(n - 1).@(r - 1) + table.@(n - 1).@(r);
            table.mod(n, set(r, x))
        )
    )
);